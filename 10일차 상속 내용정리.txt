[오버라이딩]
 : 부모클래스로부터 상속받은 메소드의 내부를 현재 클래스의 용도에 맞춰서 재작성
 : 조건 - 반드시 부모클래스의 메소드 형식(반환형, 메소드이름, 매개변수)을 그대로
            유지시켜야 오버라이딩으로 인정됨.
 : 이 때 상속받은 원본 메소드가 사라지는 아님!
-------------------------------------------------------------------------
[상속 주의사항]
1. 부모의 private 멤버에는 접근 불가능.
   (없는건 아님. 받았으나 접근이 불가능!)
   (자식 클래스에서 해당 멤버를 사용하게 하려면 protected 또는 필드는 
    getter/setter제공)
2.  자식 클래스의 생성자는 반.드.시 부모 생성자를 먼저 호출한 후 
   나머지 초기화 작업을 진행해야함!
    만약 자식 생성자에서 부모 생성자 호출을 하지 않은 경우
   컴파일러가 자식 생성자 메소드 제일 첫 줄에 super(); 문장을 끼워넣음!
   (컴파일러가 자동으로 super(); 끼워넣었는데 부모에 Car() 없으면? 에러남!)
3. 오버라이딩 시 접근지정권한 축소는 불가능.(할일 없음....;;)
4. 부모 클래스의 메소드를 오버라이딩 할 때 static 변경 불가.
-----------------------------------------------------------------------------
[@Override 애노테이션]
작성하고 있는 메소드가 반드시 오버라이딩 규칙을 지켜서 부모와 동일하게
작성하겠다는 약속 개념. 위배됐을 경우 컴파일러가 체크해서 에러라고 보여줌.
-----------------------------------------------------------------------------
[super 참조변수의 용도]
1. 자식 생성자에서 부모 생성자 명시적으로 호출할 때
2. 자식 멤버와 부모한테서 받아온 멤버 구분할 때
